-----
Object subclass: #Rectangle
	instanceVariableNames: ' origin  corner '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Primitives'!

Rectangle comment: '
I represent a rectangular area of the screen. Arithmetic functions take points as arguments and carry out scaling and translating operations to create new instances of me. Rectangle functions create new instances by determining intersections of rectangles with rectangles.

Note 1: only rectangles parallel to reference frame (Screen) can be represented by this class.

Note 2: the Rectangle is represented by two extremities of one diagonal. By convention, it must be the diagonal:
	from rectangle origin (the point having smallest coordinates in reference frame),
	to rectangle corner (the point having largest coordinates in reference frame).

Note 3: Screen coordinates conventions are:
	x is horizontal axis, zero at left border, oriented toward right;
	y is vertical axis, zero at top border, oriented toward bottom.
This corresponds to the latin convention for writing text from left to right and top to bottom.

Note 4: the Rectangle extent is obtained by subtracting rectangle origin to rectangle corner coordinates.
If this leads to a negative width (extent x coordinate) and/or a negative height (extent y coordinate), then the Rectangle is degenerated and considered empty.

Instance variables:
	origin	<Point> the coordinates of corner having smallest coordinates (top left in Screen coordinates)
	corner	<Point> the coordinates of corner having largest coordinates (bottom right in Screen coordinates) '!

!Rectangle methodsFor: 'accessing'!



aboveCenter
    ^ (( self  topLeft) + ( self  bottomRight)  ( 2  @  3 )) .
 ! !

!Rectangle methodsFor: 'accessing'!



area
    | w |
    ((( self  width)   0 ) ifTrue: [ ^  0  .]) .
    ^ (( w  * ( self  height)) max:  0 ) .
 ! !

!Rectangle methodsFor: 'accessing'!



bottom
    ^ ( corner  y) .
 ! !

!Rectangle methodsFor: 'accessing'!



bottom: aNumber 
    ^ ( origin  corner: (( corner  x) @  aNumber )) .
 ! !

!Rectangle methodsFor: 'accessing'!



bottomCenter
    ^ (( self  center x) @ ( self  bottom)) .
 ! !

!Rectangle methodsFor: 'accessing'!



bottomLeft
    ^ (( origin  x) @ ( corner  y)) .
 ! !

!Rectangle methodsFor: 'accessing'!



bottomRight
    ^  corner  .
 ! !

!Rectangle methodsFor: 'accessing'!



boundingBox
    ^  self  .
 ! !

!Rectangle methodsFor: 'accessing'!



center
    ^ (( self  topLeft) + ( self  bottomRight)   2 ) .
 ! !

!Rectangle methodsFor: 'accessing'!



corner
    ^  corner  .
 ! !

!Rectangle methodsFor: 'accessing'!



corners
    ^ ( Array  with: ( self  topLeft) with: ( self  bottomLeft) with: ( self  bottomRight) with: ( self  topRight)) .
 ! !

!Rectangle methodsFor: 'accessing'!



extent
    ^ ( corner  -  origin ) .
 ! !

!Rectangle methodsFor: 'accessing'!



height
    ^ (( corner  y) - ( origin  y)) .
 ! !

!Rectangle methodsFor: 'accessing'!



innerCorners
    | r1 |
     r1  := (( self  topLeft) corner: (( self  bottomRight) - ( 1  @  1 ))) .
    ^ ( Array  with: ( r1  topLeft) with: ( r1  bottomLeft) with: ( r1  bottomRight) with: ( r1  topRight)) .
 ! !

!Rectangle methodsFor: 'accessing'!



left
    ^ ( origin  x) .
 ! !

!Rectangle methodsFor: 'accessing'!



left: aNumber 
    ^ (( aNumber  @ ( origin  y)) corner:  corner ) .
 ! !

!Rectangle methodsFor: 'accessing'!



leftCenter
    ^ (( self  left) @ ( self  center y)) .
 ! !

!Rectangle methodsFor: 'accessing'!



origin
    ^  origin  .
 ! !

!Rectangle methodsFor: 'accessing'!



right
    ^ ( corner  x) .
 ! !

!Rectangle methodsFor: 'accessing'!



right: aNumber 
    ^ ( origin  corner: ( aNumber  @ ( corner  y))) .
 ! !

!Rectangle methodsFor: 'accessing'!



rightCenter
    ^ (( self  right) @ ( self  center y)) .
 ! !

!Rectangle methodsFor: 'accessing'!



top
    ^ ( origin  y) .
 ! !

!Rectangle methodsFor: 'accessing'!



top: aNumber 
    ^ ((( origin  x) @  aNumber ) corner:  corner ) .
 ! !

!Rectangle methodsFor: 'accessing'!



topCenter
    ^ (( self  center x) @ ( self  top)) .
 ! !

!Rectangle methodsFor: 'accessing'!



topLeft
    ^  origin  .
 ! !

!Rectangle methodsFor: 'accessing'!



topRight
    ^ (( corner  x) @ ( origin  y)) .
 ! !

!Rectangle methodsFor: 'accessing'!



width
    ^ (( corner  x) - ( origin  x)) .
 ! !

!Rectangle methodsFor: 'comparing'!



= aRectangle
    ((( self  species) = ( aRectangle  species)) ifTrue: [ ^ (( origin  = ( aRectangle  origin)) and: [( corner  = ( aRectangle  corner)) .]) .] ifFalse: [ ^  false  .]) .
 ! !

!Rectangle methodsFor: 'comparing'!



hash
    ^ (( origin  hash) bitXor: ( corner  hash)) .
 ! !

!Rectangle methodsFor: 'FMP'!



deltaToEnsureInOrCentered: r extra: aNumber 
    | dX dY halfXDiff halfYDiff |
     dX  :=  dY  :=  0  .
     halfXDiff  := ((( r  width) - ( self  width) *  aNumber ) truncated) .
     halfYDiff  := ((( r  height) - ( self  height) *  aNumber ) truncated) .
    ((( self  left) < ( r  left)) ifTrue: [ dX  := (( self  left) - ( r  left) -  halfXDiff ) .] ifFalse: [((( self  right) > ( r  right)) ifTrue: [ dX  := (( self  right) - ( r  right) +  halfXDiff ) .]) .]) .
    ((( self  top) < ( r  top)) ifTrue: [ dY  := (( self  top) - ( r  top) -  halfYDiff ) .] ifFalse: [((( self  bottom) > ( r  bottom)) ifTrue: [ dY  := (( self  bottom) - ( r  bottom) +  halfYDiff ) .]) .]) .
    ^ ( dX  @  dY ) .
 ! !

!Rectangle methodsFor: 'printing'!



printOn: aStream 
    ( origin  printOn:  aStream ) .
    ( aStream  nextPutAll: ' corner: ') .
    ( corner  printOn:  aStream ) .
 ! !

!Rectangle methodsFor: 'printing'!



storeOn: aStream 
    ( aStream  nextPut: $() .
    ( self  printOn:  aStream ) .
    ( aStream  nextPut: $)) .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



adjustTo: newRect along: side 
    (( side  =  #left) ifTrue: [ ^ ( self  withRight: ( newRect  left)) .]) .
    (( side  =  #right) ifTrue: [ ^ ( self  withLeft: ( newRect  right)) .]) .
    (( side  =  #top) ifTrue: [ ^ ( self  withBottom: ( newRect  top)) .]) .
    (( side  =  #bottom) ifTrue: [ ^ ( self  withTop: ( newRect  bottom)) .]) .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



allAreasOutsideList: aCollection do: aBlock 
    ^ ( self  allAreasOutsideList:  aCollection  startingAt:  1  do:  aBlock ) .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



allAreasOutsideList: aCollection startingAt: startIndex do: aBlock 
    | yOrigin yCorner aRectangle index rr |
     index  :=  startIndex  .
    ([(( index   ( aCollection  size)) ifFalse: [ ^ ( aBlock  value:  self ) .]) . aRectangle  := ( aCollection  at:  index ) .(( origin   ( aRectangle  corner)) and: [(( aRectangle  origin)   corner ) .]) .] whileFalse: [ index  := ( index  +  1 ) .]) .
    ((( aRectangle  origin y) > ( origin  y)) ifTrue: [ rr  := ( origin  corner: (( corner  x) @ ( aRectangle  origin y))) .( rr  allAreasOutsideList:  aCollection  startingAt: ( index  +  1 ) do:  aBlock ) .] ifFalse: [ yOrigin  := ( origin  y) .]) .
    ((( aRectangle  corner y) < ( corner  y)) ifTrue: [ rr  := ((( origin  x) @ ( aRectangle  corner y)) corner:  corner ) .( rr  allAreasOutsideList:  aCollection  startingAt: ( index  +  1 ) do:  aBlock ) .] ifFalse: [ yCorner  := ( corner  y) .]) .
    ((( aRectangle  origin x) > ( origin  x)) ifTrue: [ rr  := ((( origin  x) @  yOrigin ) corner: (( aRectangle  origin x) @  yCorner )) .( rr  allAreasOutsideList:  aCollection  startingAt: ( index  +  1 ) do:  aBlock ) .]) .
    ((( aRectangle  corner x) < ( corner  x)) ifTrue: [ rr  := ((( aRectangle  corner x) @  yOrigin ) corner: (( corner  x) @  yCorner )) .( rr  allAreasOutsideList:  aCollection  startingAt: ( index  +  1 ) do:  aBlock ) .]) .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



amountToTranslateWithin: aRectangle 
    | dx dy |
     dx  :=  0  .
     dy  :=  0  .
    ((( self  right) > ( aRectangle  right)) ifTrue: [ dx  := (( aRectangle  right) - ( self  right)) .]) .
    ((( self  bottom) > ( aRectangle  bottom)) ifTrue: [ dy  := (( aRectangle  bottom) - ( self  bottom)) .]) .
    (((( self  left) +  dx ) < ( aRectangle  left)) ifTrue: [ dx  := (( aRectangle  left) - ( self  left)) .]) .
    (((( self  top) +  dy ) < ( aRectangle  top)) ifTrue: [ dy  := (( aRectangle  top) - ( self  top)) .]) .
    ^ ( dx  @  dy ) .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



areasOutside: aRectangle 
    | areas yOrigin yCorner |
    (( self  intersects:  aRectangle ) ifFalse: [ ^ ( Array  with:  self ) .]) .
     areas  := ( OrderedCollection  new) .
    ((( aRectangle  origin y) > ( origin  y)) ifTrue: [( areas  addLast: ( origin  corner: (( corner  x) @ ( aRectangle  origin y)))) .] ifFalse: [ yOrigin  := ( origin  y) .]) .
    ((( aRectangle  corner y) < ( corner  y)) ifTrue: [( areas  addLast: ((( origin  x) @ ( aRectangle  corner y)) corner:  corner )) .] ifFalse: [ yCorner  := ( corner  y) .]) .
    ((( aRectangle  origin x) > ( origin  x)) ifTrue: [( areas  addLast: ((( origin  x) @  yOrigin ) corner: (( aRectangle  origin x) @  yCorner ))) .]) .
    ((( aRectangle  corner x) < ( corner  x)) ifTrue: [( areas  addLast: ((( aRectangle  corner x) @  yOrigin ) corner: (( corner  x) @  yCorner ))) .]) .
    ^  areas  .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



bordersOn: her along: herSide 
    (((( herSide  =  #right) and: [(( self  left) = ( her  right)) .]) | (( herSide  =  #left) and: [(( self  right) = ( her  left)) .])) ifTrue: [ ^ ((( self  top) max: ( her  top)) < (( self  bottom) min: ( her  bottom))) .]) .
    (((( herSide  =  #bottom) and: [(( self  top) = ( her  bottom)) .]) | (( herSide  =  #top) and: [(( self  bottom) = ( her  top)) .])) ifTrue: [ ^ ((( self  left) max: ( her  left)) < (( self  right) min: ( her  right))) .]) .
    ^  false  .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



encompass: aPoint 
    ^ ( Rectangle  origin: ( origin  min:  aPoint ) corner: ( corner  max:  aPoint )) .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



expandBy: delta 
    (( delta  isRectangle) ifTrue: [ ^ ( Rectangle  origin: ( origin  - ( delta  origin)) corner: ( corner  + ( delta  corner))) .] ifFalse: [ ^ ( Rectangle  origin: ( origin  -  delta ) corner: ( corner  +  delta )) .]) .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



extendBy: delta 
    (( delta  isRectangle) ifTrue: [ ^ ( Rectangle  origin:  origin  corner: ( corner  + ( delta  corner))) .] ifFalse: [ ^ ( Rectangle  origin:  origin  corner: ( corner  +  delta )) .]) .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



forPoint: aPoint closestSideDistLen: sideDistLenBlock 
    | side |
     side  := ( self  sideNearestTo:  aPoint ) .
    (( side    #right) ifTrue: [ ^ ( sideDistLenBlock  value:  side  value: ((( self  right) - ( aPoint  x)) abs) value: ((( aPoint  y) between: ( self  top) and: ( self  bottom)) ifTrue: [( self  height) .] ifFalse: [ 0  .])) .]) .
    (( side    #left) ifTrue: [ ^ ( sideDistLenBlock  value:  side  value: ((( self  left) - ( aPoint  x)) abs) value: ((( aPoint  y) between: ( self  top) and: ( self  bottom)) ifTrue: [( self  height) .] ifFalse: [ 0  .])) .]) .
    (( side    #bottom) ifTrue: [ ^ ( sideDistLenBlock  value:  side  value: ((( self  bottom) - ( aPoint  y)) abs) value: ((( aPoint  x) between: ( self  left) and: ( self  right)) ifTrue: [( self  width) .] ifFalse: [ 0  .])) .]) .
    (( side    #top) ifTrue: [ ^ ( sideDistLenBlock  value:  side  value: ((( self  top) - ( aPoint  y)) abs) value: ((( aPoint  x) between: ( self  left) and: ( self  right)) ifTrue: [( self  width) .] ifFalse: [ 0  .])) .]) .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



insetBy: delta 
    (( delta  isRectangle) ifTrue: [ ^ ( Rectangle  origin: ( origin  + ( delta  origin)) corner: ( corner  - ( delta  corner))) .] ifFalse: [ ^ ( Rectangle  origin: ( origin  +  delta ) corner: ( corner  -  delta )) .]) .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



insetOriginBy: originDeltaPoint cornerBy: cornerDeltaPoint 
    ^ ( Rectangle  origin: ( origin  +  originDeltaPoint ) corner: ( corner  -  cornerDeltaPoint )) .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



intersect: aRectangle 
    | aPoint left right top bottom |
     aPoint  := ( aRectangle  origin) .
    ((( aPoint  x) > ( origin  x)) ifTrue: [ left  := ( aPoint  x) .] ifFalse: [ left  := ( origin  x) .]) .
    ((( aPoint  y) > ( origin  y)) ifTrue: [ top  := ( aPoint  y) .] ifFalse: [ top  := ( origin  y) .]) .
     aPoint  := ( aRectangle  corner) .
    ((( aPoint  x) < ( corner  x)) ifTrue: [ right  := ( aPoint  x) .] ifFalse: [ right  := ( corner  x) .]) .
    ((( aPoint  y) < ( corner  y)) ifTrue: [ bottom  := ( aPoint  y) .] ifFalse: [ bottom  := ( corner  y) .]) .
    ^ ( Rectangle  origin: ( left  @  top ) corner: ( right  @  bottom )) .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



merge: aRectangle 
    ^ ( Rectangle  origin: ( origin  min: ( aRectangle  origin)) corner: ( corner  max: ( aRectangle  corner))) .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



outsetBy: delta 
    (( delta  isRectangle) ifTrue: [ ^ ( Rectangle  origin: ( origin  - ( delta  origin)) corner: ( corner  + ( delta  corner))) .] ifFalse: [ ^ ( Rectangle  origin: ( origin  -  delta ) corner: ( corner  +  delta )) .]) .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



pointAtFraction: relativePoint 
    | result |
     result  := (( self  origin) + (( self  extent) *  relativePoint )) .
    ^ (( self  isIntegerRectangle) ifTrue: [( result  floor) .] ifFalse: [ result  .]) .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



pointNearestTo: aPoint 
    | side |
    (( self  containsPoint:  aPoint ) ifTrue: [ side  := ( self  sideNearestTo:  aPoint ) .(( side    #right) ifTrue: [ ^ (( self  right) @ ( aPoint  y)) .]) .(( side    #left) ifTrue: [ ^ (( self  left) @ ( aPoint  y)) .]) .(( side    #bottom) ifTrue: [ ^ (( aPoint  x) @ ( self  bottom)) .]) .(( side    #top) ifTrue: [ ^ (( aPoint  x) @ ( self  top)) .]) .] ifFalse: [ ^ ( aPoint  adhereTo:  self ) .]) .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



quickMerge: aRectangle 
    | useRcvr rOrigin rCorner minX maxX minY maxY |
     useRcvr  :=  true  .
     rOrigin  := ( aRectangle  topLeft) .
     rCorner  := ( aRectangle  bottomRight) .
     minX  := ((( rOrigin  x) < ( origin  x)) ifTrue: [ useRcvr  :=  false  .( rOrigin  x) .] ifFalse: [( origin  x) .]) .
     maxX  := ((( rCorner  x) > ( corner  x)) ifTrue: [ useRcvr  :=  false  .( rCorner  x) .] ifFalse: [( corner  x) .]) .
     minY  := ((( rOrigin  y) < ( origin  y)) ifTrue: [ useRcvr  :=  false  .( rOrigin  y) .] ifFalse: [( origin  y) .]) .
     maxY  := ((( rCorner  y) > ( corner  y)) ifTrue: [ useRcvr  :=  false  .( rCorner  y) .] ifFalse: [( corner  y) .]) .
    ( useRcvr  ifTrue: [ ^  self  .] ifFalse: [ ^ ( Rectangle  origin: ( minX  @  minY ) corner: ( maxX  @  maxY )) .]) .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



rectanglesAt: y height: ht 
    ((( y  +  ht ) > ( self  bottom)) ifTrue: [ ^ ( Array  new) .]) .
    ^ ( Array  with: ((( origin  x) @  y ) corner: (( corner  x) @ ( y  +  ht )))) .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



sideNearestTo: aPoint 
    | distToLeft distToRight distToTop distToBottom closest side |
     distToLeft  := (( aPoint  x) - ( self  left)) .
     distToRight  := (( self  right) - ( aPoint  x)) .
     distToTop  := (( aPoint  y) - ( self  top)) .
     distToBottom  := (( self  bottom) - ( aPoint  y)) .
     closest  :=  distToLeft  .
     side  :=  #left .
    (( distToRight  <  closest ) ifTrue: [ closest  :=  distToRight  . side  :=  #right .]) .
    (( distToTop  <  closest ) ifTrue: [ closest  :=  distToTop  . side  :=  #top .]) .
    (( distToBottom  <  closest ) ifTrue: [ closest  :=  distToBottom  . side  :=  #bottom .]) .
    ^  side  .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



swallow: aRectangle 
     origin  := ( origin  min: ( aRectangle  origin)) .
     corner  := ( corner  max: ( aRectangle  corner)) .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



translatedToBeWithin: aRectangle 
    ^ ( self  translateBy: ( self  amountToTranslateWithin:  aRectangle )) .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



withBottom: y 
    ^ ((( origin  x) @ ( origin  y)) corner: (( corner  x) @  y )) .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



withHeight: height 
    ^ ( origin  corner: (( corner  x) @ (( origin  y) +  height ))) .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



withLeft: x 
    ^ (( x  @ ( origin  y)) corner: (( corner  x) @ ( corner  y))) .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



withRight: x 
    ^ ((( origin  x) @ ( origin  y)) corner: ( x  @ ( corner  y))) .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



withSide: side setTo: value 
    ^ ( self  perform: (#( #withLeft:  #withRight:  #withTop:  #withBottom: ) at: (#( #left  #right  #top  #bottom ) indexOf:  side )) with:  value ) .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



withSideOrCorner: side setToPoint: newPoint 
    ^ ( self  withSideOrCorner:  side  setToPoint:  newPoint  minExtent: ( 0  @  0 )) .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



withSideOrCorner: side setToPoint: newPoint minExtent: minExtent 
    ^ ( self  withSideOrCorner:  side  setToPoint:  newPoint  minExtent:  minExtent  limit: ((#( #left  #top ) includes:  side ) ifTrue: [( SmallInteger  minVal) .] ifFalse: [( SmallInteger  maxVal) .])) .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



withSideOrCorner: side setToPoint: newPoint minExtent: minExtent limit: limit 
    (( side  =  #top) ifTrue: [ ^ ( self  withTop: (( newPoint  y) min: (( corner  y) - ( minExtent  y)) max: ( limit  + ( minExtent  y)))) .]) .
    (( side  =  #bottom) ifTrue: [ ^ ( self  withBottom: (( newPoint  y) min: ( limit  - ( minExtent  y)) max: (( origin  y) + ( minExtent  y)))) .]) .
    (( side  =  #left) ifTrue: [ ^ ( self  withLeft: (( newPoint  x) min: (( corner  x) - ( minExtent  x)) max: ( limit  + ( minExtent  x)))) .]) .
    (( side  =  #right) ifTrue: [ ^ ( self  withRight: (( newPoint  x) min: ( limit  - ( minExtent  x)) max: (( origin  x) + ( minExtent  x)))) .]) .
    (( side  =  #topLeft) ifTrue: [ ^ (( newPoint  min: ( corner  -  minExtent )) corner: ( self  bottomRight)) .]) .
    (( side  =  #bottomRight) ifTrue: [ ^ (( self  topLeft) corner: ( newPoint  max: ( origin  +  minExtent ))) .]) .
    (( side  =  #bottomLeft) ifTrue: [ ^ (( self  topRight) rect: ((( newPoint  x) min: (( corner  x) - ( minExtent  x))) @ (( newPoint  y) max: (( origin  y) + ( minExtent  y))))) .]) .
    (( side  =  #topRight) ifTrue: [ ^ (( self  bottomLeft) rect: ((( newPoint  x) max: (( origin  x) + ( minExtent  x))) @ (( newPoint  y) min: (( corner  y) - ( minExtent  y))))) .]) .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



withTop: y 
    ^ ((( origin  x) @  y ) corner: (( corner  x) @ ( corner  y))) .
 ! !

!Rectangle methodsFor: 'rectangle functions'!



withWidth: width 
    ^ ( origin  corner: ((( origin  x) +  width ) @ ( corner  y))) .
 ! !

!Rectangle methodsFor: 'testing'!



containsPoint: aPoint 
    ^ (( origin    aPoint ) and: [( aPoint  <  corner ) .]) .
 ! !

!Rectangle methodsFor: 'testing'!



containsRect: aRect 
    ^ ((( aRect  origin)   origin ) and: [(( aRect  corner)   corner ) .]) .
 ! !

!Rectangle methodsFor: 'testing'!



hasPositiveExtent
    ^ ((( corner  x) > ( origin  x)) and: [(( corner  y) > ( origin  y)) .]) .
 ! !

!Rectangle methodsFor: 'testing'!



intersects: aRectangle 
    | rOrigin rCorner |
     rOrigin  := ( aRectangle  origin) .
     rCorner  := ( aRectangle  corner) .
    ((( rCorner  x)  ( origin  x)) ifTrue: [ ^  false  .]) .
    ((( rCorner  y)  ( origin  y)) ifTrue: [ ^  false  .]) .
    ((( rOrigin  x)  ( corner  x)) ifTrue: [ ^  false  .]) .
    ((( rOrigin  y)  ( corner  y)) ifTrue: [ ^  false  .]) .
    ((( corner  x) < ( origin  x)) ifTrue: [ ^  false  .]) .
    ((( corner  y) < ( origin  y)) ifTrue: [ ^  false  .]) .
    ((( rCorner  x) < ( rOrigin  x)) ifTrue: [ ^  false  .]) .
    ((( rCorner  y) < ( rOrigin  y)) ifTrue: [ ^  false  .]) .
    ^  true  .
 ! !

!Rectangle methodsFor: 'testing'!



isRectangle
    ^  true  .
 ! !

!Rectangle methodsFor: 'testing'!



isTall
    ^ (( self  height) > ( self  width)) .
 ! !

!Rectangle methodsFor: 'testing'!



isWide
    ^ (( self  width) > ( self  height)) .
 ! !

!Rectangle methodsFor: 'testing'!



isZero
    ^ (( origin  isZero) and: [( corner  isZero) .]) .
 ! !

!Rectangle methodsFor: 'transforming'!



align: aPoint1 with: aPoint2 
    ^ ( self  translateBy: ( aPoint2  -  aPoint1 )) .
 ! !

!Rectangle methodsFor: 'transforming'!



bottomHalf
    ^ ( self  withTop: ( self  center y)) .
 ! !

!Rectangle methodsFor: 'transforming'!



bottomLeftQuadrant
    ^ (( self  leftCenter) corner: ( self  bottomCenter)) .
 ! !

!Rectangle methodsFor: 'transforming'!



bottomRightQuadrant
    ^ (( self  center) corner: ( self  bottomRight)) .
 ! !

!Rectangle methodsFor: 'transforming'!



centeredBeneath: aRectangle 
    ^ ( self  align: ( self  topCenter) with: ( aRectangle  bottomCenter)) .
 ! !

!Rectangle methodsFor: 'transforming'!



flipBy: direction centerAt: aPoint 
    | futureOrigin futureCorner |
    (( direction    #horizontal) ifTrue: [ futureOrigin  := ( self  topRight) . futureCorner  := ( self  bottomLeft) .] ifFalse: [(( direction    #vertical) ifTrue: [ futureOrigin  := ( self  bottomLeft) . futureCorner  := ( self  topRight) .] ifFalse: [( self  error: 'unrecognizable direction') .]) .]) .
    ^ (( futureOrigin  flipBy:  direction  centerAt:  aPoint ) corner: ( futureCorner  flipBy:  direction  centerAt:  aPoint )) .
 ! !

!Rectangle methodsFor: 'transforming'!



leftHalf
    ^ ( self  withRight: ( self  center x)) .
 ! !

!Rectangle methodsFor: 'transforming'!



newRectButtonPressedDo: newRectBlock 
    | rect newRect buttonNow delay |
     delay  := ( Delay  forMilliseconds:  10 ) .
     buttonNow  := ( Sensor  anyButtonPressed) .
     rect  :=  self  .
    ( Display  border:  rect  width:  2  rule: ( Form  reverse) fillColor: ( Color  gray)) .
    ([ buttonNow  .] whileTrue: [( delay  wait) . buttonNow  := ( Sensor  anyButtonPressed) . newRect  := ( newRectBlock  value:  rect ) .(( newRect  =  rect ) ifFalse: [( Display  border:  rect  width:  2  rule: ( Form  reverse) fillColor: ( Color  gray)) .( Display  border:  newRect  width:  2  rule: ( Form  reverse) fillColor: ( Color  gray)) . rect  :=  newRect  .]) .]) .
    ( Display  border:  rect  width:  2  rule: ( Form  reverse) fillColor: ( Color  gray)) .
    ( Project  current pointerMoved) .
    ( Sensor  processEvent: ( Sensor  createMouseEvent)) .
    ^  rect  .
 ! !

!Rectangle methodsFor: 'transforming'!



newRectFrom: newRectBlock 
    | rect newRect buttonStart buttonNow delay |
     delay  := ( Delay  forMilliseconds:  10 ) .
     buttonStart  :=  buttonNow  := ( Sensor  anyButtonPressed) .
     rect  :=  self  .
    ( Display  border:  rect  width:  2  rule: ( Form  reverse) fillColor: ( Color  gray)) .
    ([( buttonNow    buttonStart ) .] whileTrue: [( delay  wait) . buttonNow  := ( Sensor  anyButtonPressed) . newRect  := ( newRectBlock  value:  rect ) .(( newRect  =  rect ) ifFalse: [( Display  border:  rect  width:  2  rule: ( Form  reverse) fillColor: ( Color  gray)) .( Display  border:  newRect  width:  2  rule: ( Form  reverse) fillColor: ( Color  gray)) . rect  :=  newRect  .]) .]) .
    ( Display  border:  rect  width:  2  rule: ( Form  reverse) fillColor: ( Color  gray)) .
    ( Project  current pointerMoved) .
    ( Sensor  processEvent: ( Sensor  createMouseEvent)) .
    ^  rect  .
 ! !

!Rectangle methodsFor: 'transforming'!



rightHalf
    ^ ( self  withLeft: ( self  center x)) .
 ! !

!Rectangle methodsFor: 'transforming'!



rotateBy: direction centerAt: aPoint 
    | futureOrigin futureCorner |
    (( direction    #pi) ifTrue: [ futureOrigin  := ( self  corner) . futureCorner  := ( self  origin) .] ifFalse: [(( direction    #left) ifTrue: [ futureOrigin  := ( self  topRight) . futureCorner  := ( self  bottomLeft) .] ifFalse: [(( direction    #right) ifTrue: [ futureOrigin  := ( self  bottomLeft) . futureCorner  := ( self  topRight) .] ifFalse: [( self  error: 'unrecognizable direction') .]) .]) .]) .
    ^ (( futureOrigin  rotateBy:  direction  centerAt:  aPoint ) corner: ( futureCorner  rotateBy:  direction  centerAt:  aPoint )) .
 ! !

!Rectangle methodsFor: 'transforming'!



scaleBy: scale 
    ^ ( Rectangle  origin: ( origin  *  scale ) corner: ( corner  *  scale )) .
 ! !

!Rectangle methodsFor: 'transforming'!



scaleFrom: rect1 to: rect2 
    ^ (( origin  scaleFrom:  rect1  to:  rect2 ) corner: ( corner  scaleFrom:  rect1  to:  rect2 )) .
 ! !

!Rectangle methodsFor: 'transforming'!



squishedWithin: aRectangle 
    ^ ( origin  corner: ( corner  min: ( aRectangle  bottomRight))) .
 ! !

!Rectangle methodsFor: 'transforming'!



topHalf
    ^ ( self  withBottom: ( self  center y)) .
 ! !

!Rectangle methodsFor: 'transforming'!



topLeftQuadrant
    ^ (( self  topLeft) corner: ( self  center)) .
 ! !

!Rectangle methodsFor: 'transforming'!



topRightQuadrant
    ^ (( self  topCenter) corner: ( self  rightCenter)) .
 ! !

!Rectangle methodsFor: 'transforming'!



translateBy: factor 
    ^ ( Rectangle  origin: ( origin  +  factor ) corner: ( corner  +  factor )) .
 ! !

!Rectangle methodsFor: 'transforming'!



translatedAndSquishedToBeWithin: aRectangle 
    ^ (( self  translatedToBeWithin:  aRectangle ) squishedWithin:  aRectangle ) .
 ! !

!Rectangle methodsFor: 'truncation and round off'!



ceiling
    (( self  isIntegerRectangle) ifTrue: [ ^  self  .]) .
    ^ (( origin  ceiling) corner: ( corner  ceiling)) .
 ! !

!Rectangle methodsFor: 'truncation and round off'!



compressTo: grid 
    ^ ( Rectangle  origin: ( origin  roundUpTo:  grid ) corner: ( corner  roundDownTo:  grid )) .
 ! !

!Rectangle methodsFor: 'truncation and round off'!



compressed
    ^ ( Rectangle  origin: ( origin  ceiling) corner: ( corner  floor)) .
 ! !

!Rectangle methodsFor: 'truncation and round off'!



expandTo: grid 
    ^ ( Rectangle  origin: ( origin  roundDownTo:  grid ) corner: ( corner  roundUpTo:  grid )) .
 ! !

!Rectangle methodsFor: 'truncation and round off'!



expanded
    ^ ( Rectangle  origin: ( origin  floor) corner: ( corner  ceiling)) .
 ! !

!Rectangle methodsFor: 'truncation and round off'!



floor
    (( self  isIntegerRectangle) ifTrue: [ ^  self  .]) .
    ^ (( origin  floor) corner: ( corner  floor)) .
 ! !

!Rectangle methodsFor: 'truncation and round off'!



isIntegerRectangle
    ^ (( origin  isIntegerPoint) and: [( corner  isIntegerPoint) .]) .
 ! !

!Rectangle methodsFor: 'truncation and round off'!



roundTo: grid 
    ^ ( Rectangle  origin: ( origin  roundTo:  grid ) corner: ( corner  roundTo:  grid )) .
 ! !

!Rectangle methodsFor: 'truncation and round off'!



rounded
    ^ ( Rectangle  origin: ( origin  rounded) extent: ( self  extent rounded)) .
 ! !

!Rectangle methodsFor: 'truncation and round off'!



truncateTo: grid 
    ^ ( Rectangle  origin: ( origin  truncateTo:  grid ) corner: ( corner  truncateTo:  grid )) .
 ! !

!Rectangle methodsFor: 'truncation and round off'!



truncated
    ((( origin  x isInteger) and: [(( origin  y isInteger) and: [(( corner  x isInteger) and: [( corner  y isInteger) .]) .]) .]) ifTrue: [ ^  self  .]) .
    ^ ( Rectangle  origin: ( origin  truncated) corner: ( corner  truncated)) .
 ! !

!Rectangle methodsFor: 'private'!



setOrigin: topLeft corner: bottomRight 
     origin  :=  topLeft  .
     corner  :=  bottomRight  .
 ! !

!Rectangle methodsFor: '*Etoys-Squeakland-comparing'!



hashMappedBy: map 
    ^ ( self  hash) .
 ! !

!Rectangle methodsFor: '*Etoys-Squeakland-testing'!



intersectsAny: rectangleList 
    ( rectangleList  do: [ :r |(( self  intersects:  r ) ifTrue: [ ^  true  .]) .]) .
    ^  false  .
 ! !

!Rectangle methodsFor: '*MorphicExtras-Postscript Canvases'!



encodePostscriptOn: aStream 
    ( aStream  write: ( self  origin) ;  print: ' ' ;  write: ( self  extent) ;  print: ' ') .
 ! !

!Rectangle methodsFor: '*nebraska-Morphic-Remote'!



encodeForRemoteCanvas
    | encoded |
    ( CanvasEncoder  at:  2  count:  1 ) .
     encoded  := ( String  new:  16 ) .
    ( encoded  putInteger32: ( origin  x asInteger) at:  1 ) .
    ( encoded  putInteger32: ( origin  y asInteger) at:  5 ) .
    ( encoded  putInteger32: ( corner  x asInteger) at:  9 ) .
    ( encoded  putInteger32: ( corner  y asInteger) at:  13 ) .
    ^  encoded  .
 ! !

!Rectangle methodsFor: '*nebraska-Morphic-Remote'!



encodeForRemoteCanvasB
    | encoded |
     encoded  := ( Bitmap  new:  4 ) .
    ( encoded  at:  1  put: ( origin  x asInteger)) .
    ( encoded  at:  2  put: ( origin  y asInteger)) .
    ( encoded  at:  3  put: ( corner  x asInteger)) .
    ( encoded  at:  4  put: ( corner  y asInteger)) .
    ^  encoded  .
 ! !

!Rectangle methodsFor: 'random'!



randomPoint
    ^ ( self  randomPoint: ( ThreadSafeRandom  value)) .
 ! !

!Rectangle methodsFor: 'random'!



randomPoint: aGenerator 
    ^ ( self  pointAtFraction: (( aGenerator  next) @ ( aGenerator  next))) .
 ! !

"= = = == = "!
Rectangle class instanceVariableNames: '' !
!Rectangle class methodsFor: 'instance creation'!



center: centerPoint extent: extentPoint 
    ^ ( self  origin: ( centerPoint  - ( extentPoint    2 )) extent:  extentPoint ) .
 ! !
!Rectangle class methodsFor: 'instance creation'!



encompassing: listOfPoints 
    | topLeft bottomRight |
     topLeft  :=  bottomRight  := ( listOfPoints  first) .
    ( listOfPoints  allButFirstDo: [ :p | topLeft  := ( topLeft  min:  p ) . bottomRight  := ( bottomRight  max:  p ) .]) .
    ^ ( self  origin:  topLeft  corner:  bottomRight ) .
 ! !
!Rectangle class methodsFor: 'instance creation'!



exactCenter: centerPoint extent: extentPoint 
    ^ ( self  origin: ( centerPoint  - ( extentPoint  /  2 )) extent:  extentPoint ) .
 ! !
!Rectangle class methodsFor: 'instance creation'!



fromUser
    ^ ( self  fromUser: ( 1  @  1 )) .
 ! !
!Rectangle class methodsFor: 'instance creation'!



fromUser: gridPoint 
    | originRect |
     originRect  := (( Cursor  origin) showWhile: [(((( Sensor  cursorPoint) grid:  gridPoint ) extent: ( 0  @  0 )) newRectFrom: [ :f |((( Sensor  cursorPoint) grid:  gridPoint ) extent: ( 0  @  0 )) .]) .]) .
    ^ (( Cursor  corner) showWhile: [( originRect  newRectFrom: [ :f |(( f  origin) corner: (( Sensor  cursorPoint) grid:  gridPoint )) .]) .]) .
 ! !
!Rectangle class methodsFor: 'instance creation'!



left: leftNumber right: rightNumber top: topNumber bottom: bottomNumber 
    ^ (( self  basicNew) setOrigin: ( leftNumber  @  topNumber ) corner: ( rightNumber  @  bottomNumber )) .
 ! !
!Rectangle class methodsFor: 'instance creation'!



locateMagnifiedView: aForm scale: scaleFactor 
    ^ ( self  originFromUser: (( aForm  extent) *  scaleFactor  + ( 0  @  50 ))) .
 ! !
!Rectangle class methodsFor: 'instance creation'!



merging: listOfRects 
    | bottomRight topLeft |
     topLeft  := ( listOfRects  first topLeft) .
     bottomRight  := ( listOfRects  first bottomRight) .
    ( listOfRects  allButFirstDo: [ :r | topLeft  := ( topLeft  min: ( r  topLeft)) . bottomRight  := ( bottomRight  max: ( r  bottomRight)) .]) .
    ^ ( self  origin:  topLeft  corner:  bottomRight ) .
 ! !
!Rectangle class methodsFor: 'instance creation'!



origin: originPoint corner: cornerPoint 
    ^ (( self  basicNew) setOrigin:  originPoint  corner:  cornerPoint ) .
 ! !
!Rectangle class methodsFor: 'instance creation'!



origin: originPoint extent: extentPoint 
    ^ (( self  basicNew) setOrigin:  originPoint  corner: ( originPoint  +  extentPoint )) .
 ! !
!Rectangle class methodsFor: 'instance creation'!



originFromUser: extentPoint 
    ^ ( self  originFromUser:  extentPoint  grid: ( 1  @  1 )) .
 ! !
!Rectangle class methodsFor: 'instance creation'!



originFromUser: extentPoint grid: gridPoint 
    ^ (( Cursor  origin) showWhile: [(((( Sensor  cursorPoint) grid:  gridPoint ) extent:  extentPoint ) newRectFrom: [ :f |((( Sensor  cursorPoint) grid:  gridPoint ) extent:  extentPoint ) .]) .]) .
 ! !

